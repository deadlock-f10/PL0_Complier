label	Instr		arg1				arg2			 result		meaning
	1	read										     id			read a integer(char) into id
		li $v0 5   read int     /        li $v0 12     read char
		syscall
		add id.reg $zero $v0

	2	write		string				[id,integer]				write a string or id or both
		.data 
		string.name : .asciiz "string.to_string()"
		.text
		li $v0 4
		la $a0 string.name
		syscall


		li $v0 1         write int    /   li $v0 11    write char
		add $a0 id.reg $zero                 
		syscall

		li $v0 1
		add $a0 $zero integer.value
		syscall
		
	3	if			rel									 L			if relation holds then goto label L
		if rel.e1 ,rel.e2  both are constant . then anther emit nothing , or emit  " b L "
		else
			bgt rel.e1.reg , rel.e2.reg ,  L                    注意如果有常量需要把它放在第二个参数的位置，并适当变换操作符
			blt rel.e1.reg , rel.e2.reg ,  L
			bne rel.e1.reg , rel.e2.reg ,  L
			beq rel.e1.reg , rel.e2.reg ,  L
			ble rel.e1.reg , rel.e2.reg ,  L
			bge rel.e1.reg , rel.e2.reg ,  L




	4	iffalse		rel									 L			if relation doesnt' holds then goto label L

	5	invoke	    program				integer				
	5	param		(id,integer,array)								parameter id(for future use)
		la $k1 integer.value
		sw $k1 ($sp)
		sub $sp $sp 4

		sw id.reg ($sp)
		sub $sp $sp 4
	
	6	callproc	proc				integer						call procedure with n parameters
		b proc.name

	7	callfunc	func				integer			 id			call function with n parameters , store return value in id	
		b func.name
		lw id.reg offset($sp)

	8	copy		(idy,integer)						 idx		x = y
		add x.reg $zero y.reg
		add x.reg $zero integer.value

	9	copyind		idx					(idi,integer)	 idy	    y = x[i]
		//lw $k1 x.offset(%fp)             |      不一定，x可能不在本层．
		sub $k1 $k1 i.reg | integer.value 
		lw y.reg ($k1)
		

	10	indcopy		(idy,integer)		(idi,integer)	 idx		x[i] = y
		//lw $k1 x.offset(%fp)             |      不一定，x可能不在本层．                getReg应该负责把x的基址加载到k1中．这样我们就不用判断了.
		sub $k1 $k1 i.reg | integer.value
		sw y.reg ($k1)        |        li $t8 yint.value    sw $t8 ($k1)

	11	op			(idy,integer)		(idz,integer)	 idx		x = y op z (op can be +,-,*,/)
		if ar1, ar2  both are constant . then  compute it and emit "li x.reg result.value"
		else
			add	 x.reg y.reg z.reg                              考虑顺序!
			sub	 x.reg y.reg z.reg                         
			mulo x.reg y.reg z.reg
			div x.reg y.reg z.reg

	12	goto											 L          goto L
		j L
	13	end															end of this proc/func/program
		jr $ra             or nothing if it's program
