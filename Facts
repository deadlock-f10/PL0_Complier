/*
2.　不做全局公共子表达式消除.　临时变量唯一跨越Basic Block的可能性来自于表达式中的函数调用.　而函数调用本身不会改变临时变量的值(可能改变本层普通变量的值)．
所以是不是可以这样，在函数调用时，清除掉所有普通变量的信息(因为可能在函数调用中被改变，这样返回后会出现寄存器与栈上不同步的现象)，
但是保留所有临时寄存器的值(在栈上),函数返回后恢复现场．这样可以避免在分析next-use时出现临时变量被分割在了两个基本块中的情况．

2.　最终决定这样做:对每个程序只允许最大使用20个临时寄存器(也就是说在保存寄存器时最多需要保存20个)
	每个四元式Class包含一个field，表示它对应的一串指令.然后不把函数/过程调用当做分隔基本块的标志.
	遇到函数，过程调用时，把
	
3.　在调用函数/过程前后，需要进行现场的保护与恢复，使得调用前后Register and Address Desciptor的信息一致，且及时(调用结束后把Register中对应的普通变量写回对应的Register，并清空该Register的其他变量)            -------放弃吧，已经前后不一致了.
*/

1.	寄存器分配时以基本块为单位(不把函数/过程调用当做分隔基本块的标志)，对每个基本块分别建立next-use 信息(注意，遇到call时普通变量和参数的next-use信息自动清空)以及 liveness 信息
创建一个数据结构----Register_Address_Desc ，　保存了Address_Descs(Field为Id 以及　一个list，表示存储他的寄存器.)(symboltable )，存储了本函数所有用到的变量---参数，普通变量(本层和上层)，临时变量,以及他们对应的存储；以及一个Register_Desc(array)，保存了寄存器当前存储的变量名．

扫描两遍，第一遍从block的最后一条指令开始，把遇到的所有变量都加入Address_Descs, 并为每个四元式提供相关变量的next-use信息.

第二遍从第一个基本块的第一条指令开始，首先把符号表里普通变量的Address Desciptor设为他自己.然后调用getReg，为每个变量分配寄存器．
使用这些分配的寄存器完成四元式操作．

离开基本块后，把存储普通变量的寄存器写回.

//每个四元式包含一个field，表示它对应的那一串指令.方便修改，没有问题．

k0 是专门用来进行存储时用到的临时变量寄存器．随用随取，不参与临时寄存器分配．
k1,t8,t9 是当所有寄存器的变量都是有next-use时，使用的一个寄存器，使用了就存回．

3.	不对临时变量分配地址，只在需要的时候才把它push到栈上去(记录的任然是他与fp的相对位置)，这样，在离开这个basicblock后，临时变量就自动失效了．


4.　函数过程调用规范：
当遇到Call或者param时，先把所有普通变量及参数写回栈上，然后把他们在RAD中的信息清空，把所有保存临时变量的寄存器压栈.然后再依次推入display区(根据caller与callee的层次关系)，保存fp,sp,ret addr,参数，局部变量等． 函数调用返回后，再把保存临时变量的寄存器恢复现场． 
注意，当参数是var类型时，不传引用，而是跟其他一样传值，不过在函数调用返回过程中，需要把对应的参数写回对应的位置.
