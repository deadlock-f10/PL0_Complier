不会减少中间代码的长度，但是可以减轻强度．但最后的目标代码的长度会减少

只对表达式段(只包含copy + 四个op)进行DAG图的处理
不包括copyind 和indcopy, 因为现有的恢复算法无法满足!

所有的临时变量，一个不删，全部写回(为了不处理param)

dag的结点有两种---根节点(由常量，变量组成,分别为arg_int,arg_id类),中间结点(由Op类中前面说到的7个组成),每个结点除了有上述属性外，还有父亲节点序列以及儿子结点序列.同时，中间结点还有一个变量序列,代表了最后在此被定义的变量．        dag图由一个专门的dag类表示

结点表可由哈希表表示.

每当对一个变量赋予新的值之后，消掉原有的结点中对应的这个变量，如果原有节点中不再含有变量，则为其申请一个新的临时变量.

注意，向新的变量中插入时需要注意有无重复.(a = a的形式)

	具体算法是:
	构建dag图时，首先查找结点表中有无对应操作数，如果有记下结点号，否则申请一个新的结点，记下结点号.
	并记下dag的无父亲节点的中间节点．




为全局寄存器分配预留两个寄存器->a1,a2

复写传播扫描死代码时，可以利用现成backscan的代码，但注意必须扫描所有操作数可能出现的地方.
死代码消除时，只能消除临时变量（也就是只消除DAG图生成的对临时变量赋值语句，只消除i_copy)，其他的变量千万不要动(因为可能对一个函数内普通变量复制了但没有使用，但其实他在上一层的函数中被用到了).


全局寄存器的使用:只在进入函数后以及从函数或过程调用返回后把值从栈加载到寄存器中,此后一般无需存回栈上，只在进行函数和过程调用(I_INVOKE)之前以及函数结束前(I_END)把全局寄存器的值存回栈上．
需要注意的问题是，如果函数调用的返回值正好是被分配了全局寄存器，那么需要格外注意，因为一般的storevable无法解决这个问题．

注意一个问题，在每个Bblockgenerator的backwardscan的一开始就应该为全局变量建立好Addr_Descripter，因为有可能出现backwardscan扫描不到
全局变量的情况，因为backwardscan不扫描param

