!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Access	include/Expr.h	/^		Access (Id *id ,Type * t, Expr * e) : Op(new Word("[]" ,T_INDEX),t) {array = id ; index = e; }$/;"	f	class:Access
Access	include/Expr.h	/^class Access : public Op{$/;"	c
Arg1	include/Quadruple.h	/^class Arg1{$/;"	c
Arg2	include/Quadruple.h	/^class Arg2{$/;"	c
Arg_func	include/Quadruple.h	/^		Arg_func(Func *f){func = f;}$/;"	f	class:Arg_func
Arg_func	include/Quadruple.h	/^class Arg_func : public Arg1{$/;"	c
Arg_id	include/Quadruple.h	/^		Arg_id(Id *x){id = x;}$/;"	f	class:Arg_id
Arg_id	include/Quadruple.h	/^class Arg_id : public Arg1 ,Arg2,Result{             \/\/ maybe temp ?$/;"	c
Arg_int	include/Quadruple.h	/^		Arg_int(int x) { value = x;}$/;"	f	class:Arg_int
Arg_int	include/Quadruple.h	/^class Arg_int : public Arg1 , Arg2{$/;"	c
Arg_proc	include/Quadruple.h	/^		Arg_proc(Proc *p){proc = p;}$/;"	f	class:Arg_proc
Arg_proc	include/Quadruple.h	/^class Arg_proc : public Arg1{$/;"	c
Arg_rel	include/Quadruple.h	/^		Arg_rel(Rel * r) {relation = r;}$/;"	f	class:Arg_rel
Arg_rel	include/Quadruple.h	/^class Arg_rel : public Arg1{$/;"	c
Arg_string	include/Quadruple.h	/^		Arg_string(std::string s){str = s;}$/;"	f	class:Arg_string
Arg_string	include/Quadruple.h	/^class Arg_string : public Arg1{$/;"	c
Arith	include/Expr.h	/^class Arith : public Op {$/;"	c
Arith	inter/Expr.cpp	/^Arith::Arith(Token* tok , Expr *x1 , Expr* x2) : Op(tok, nullptr){$/;"	f	class:Arith
Array	include/Type.h	/^	Array(int sz , Type* t) : Type(T_ARRAY , sz*(t->width), "array")$/;"	f	class:Array
Array	include/Type.h	/^class Array : public Type{$/;"	c
Assign	include/Stmt.h	/^class Assign : public Stmt{$/;"	c
Assign	inter/Stmt.cpp	/^Assign::Assign(Id *id,Expr *e) {$/;"	f	class:Assign
AssignElem	include/Stmt.h	/^class AssignElem : public Stmt{$/;"	c
AssignElem	inter/Stmt.cpp	/^AssignElem::AssignElem(Access *x , Expr *y){$/;"	f	class:AssignElem
BUILDDIR	inter/Makefile	/^BUILDDIR = ..\/obj\/inter\/$/;"	m
BUILDDIR	lexer/Makefile	/^BUILDDIR = ..\/obj\/lexer\/$/;"	m
BUILDDIR	parser/Makefile	/^BUILDDIR = ..\/obj\/parser\/$/;"	m
BUILDDIR	symboltable/Makefile	/^BUILDDIR = ..\/obj\/symboltable\/$/;"	m
Block	include/PAF.h	/^class Block {$/;"	c
CC	inter/Makefile	/^CC = g++$/;"	m
CC	lexer/Makefile	/^CC = g++$/;"	m
CC	parser/Makefile	/^CC = g++$/;"	m
CC	symboltable/Makefile	/^CC = g++$/;"	m
CFLAGS	inter/Makefile	/^CFLAGS = -Wall --std=c++11$/;"	m
CFLAGS	lexer/Makefile	/^CFLAGS = -Wall -Werror --std=c++11$/;"	m
CFLAGS	parser/Makefile	/^CFLAGS = -Wall --std=c++11$/;"	m
CFLAGS	symboltable/Makefile	/^CFLAGS = -Wall --std=c++11$/;"	m
Callfunc	include/Expr.h	/^	Callfunc(Func *func , std::vector<Expr*> *list):Expr(func->name,func->type){f = func;list = actuallist;}$/;"	f	class:Callfunc
Callfunc	include/Expr.h	/^class Callfunc : public Expr{$/;"	c
Callproc	include/Stmt.h	/^	Callproc(Proc *proc , std::vector<Expr*> *list){prc = proc;list = actuallist;}$/;"	f	class:Callproc
Callproc	include/Stmt.h	/^class Callproc: public Stmt{        $/;"	c
Char	include/Type.h	/^		static Type *Int,*Char;$/;"	m	class:Type
Char	lexer/Type.cpp	/^Type* Type::Char = new Type(T_CHAR , Char_Width , "char");  $/;"	m	class:Type	file:
Char_Width	lexer/Type.cpp	3;"	d	file:
Character	include/Token.h	/^		Character(char c) : Token(T_CHARACTER){character = c; value = character;}$/;"	f	class:Character
Character	include/Token.h	/^class Character : public Token{$/;"	c
Constant	include/Expr.h	/^		Constant (Character *t): Expr(t , Type::Int){c = t->value;}$/;"	f	class:Constant
Constant	include/Expr.h	/^		Constant (Num *t): Expr(t , Type::Int){c = t->value;}$/;"	f	class:Constant
Constant	include/Expr.h	/^class Constant : public Expr {$/;"	c
Div	include/Token.h	/^		static Word *Div ; $/;"	m	class:Word
Div	lexer/Lexer.cpp	/^Word	*Word::Div = new Word("\/",T_DIV);	$/;"	m	class:Word	file:
DoWhile	include/Stmt.h	/^		DoWhile(Rel *expr , Stmt *stmt){e = expr;s =stmt;}$/;"	f	class:DoWhile
DoWhile	include/Stmt.h	/^class DoWhile : public Stmt{$/;"	c
EXPR_H	include/Expr.h	5;"	d
Expr	include/Expr.h	/^		Expr(Token* tok , Type *t) {op = tok ; type = t;}$/;"	f	class:Expr
Expr	include/Expr.h	/^class Expr : public Node{$/;"	c
For	include/Stmt.h	/^		For(Id * i,Expr *x1,bool to,Expr* x2,Stmt* stmt){$/;"	f	class:For
For	include/Stmt.h	/^class For : public Stmt{$/;"	c
Func	include/PAF.h	/^class Func : public Program{$/;"	c
Func	parser/parsedeclpaf.cpp	/^Func::Func(Program *p,Word *w, int l) {prev = p;name = w;level = l;beginlabel = Parser::getlabel(name);}$/;"	f	class:Func
HEADER_PATH	inter/Makefile	/^HEADER_PATH = ..\/include$/;"	m
HEADER_PATH	lexer/Makefile	/^HEADER_PATH = ..\/include$/;"	m
HEADER_PATH	parser/Makefile	/^HEADER_PATH = ..\/include$/;"	m
HEADER_PATH	symboltable/Makefile	/^HEADER_PATH = ..\/include$/;"	m
Hashtable	include/PAF.h	/^typedef std::unordered_map<Token* , Node*> Hashtable;$/;"	t
I_ADD	include/OP.h	/^	I_ADD ,$/;"	e	enum:OP
I_CALLFUNC	include/OP.h	/^	I_CALLFUNC ,$/;"	e	enum:OP
I_CALLPROC	include/OP.h	/^	I_CALLPROC ,$/;"	e	enum:OP
I_COPY	include/OP.h	/^	I_COPY ,$/;"	e	enum:OP
I_COPYIND	include/OP.h	/^	I_COPYIND ,$/;"	e	enum:OP
I_DIV	include/OP.h	/^	I_DIV ,$/;"	e	enum:OP
I_GOTO	include/OP.h	/^	I_GOTO,$/;"	e	enum:OP
I_IF	include/OP.h	/^	I_IF  ,$/;"	e	enum:OP
I_IFFALSE	include/OP.h	/^	I_IFFALSE ,$/;"	e	enum:OP
I_INDCOPY	include/OP.h	/^	I_INDCOPY  ,$/;"	e	enum:OP
I_MINUS	include/OP.h	/^	I_MINUS ,$/;"	e	enum:OP
I_MULT	include/OP.h	/^	I_MULT ,$/;"	e	enum:OP
I_PARAM	include/OP.h	/^	I_PARAM ,$/;"	e	enum:OP
I_READ	include/OP.h	/^	I_READ = 0 ,$/;"	e	enum:OP
I_WRITE	include/OP.h	/^	I_WRITE  ,$/;"	e	enum:OP
Id	include/Expr.h	/^		Id(Word* w , Type* t , int o , bool b,int l): Expr(w,t) {offset = o; isConst = b; level = l;}$/;"	f	class:Id
Id	include/Expr.h	/^		Id(Word* w , Type* t , int o , bool b1 , bool b2,int l): Expr(w,t) {offset = o; isConst = b1; isRef = b2; level = l;}$/;"	f	class:Id
Id	include/Expr.h	/^		Id(Word* w , Type* t , int o,int l): Expr(w,t) {offset = o; isConst = false; level = l;}$/;"	f	class:Id
Id	include/Expr.h	/^class Id : public Expr {          \/\/ need add field which specify whether this identifier is const or not$/;"	c
If	include/Stmt.h	/^		If(Rel *expr , Stmt *stmt){e = expr;s =stmt;}$/;"	f	class:If
If	include/Stmt.h	/^class If : public Stmt{$/;"	c
IfElse	include/Stmt.h	/^		IfElse(Rel *expr , Stmt *stmt1, Stmt *stmt2){e = expr;s1 =stmt1; s2 = stmt2;}$/;"	f	class:IfElse
IfElse	include/Stmt.h	/^class IfElse : public Stmt{$/;"	c
Input	include/Stmt.h	/^	Input(std::queue<Word*> *list) {idlist = list;}$/;"	f	class:Input
Input	include/Stmt.h	/^class Input: public Stmt{$/;"	c
Instrlist	include/PAF.h	/^		QuadList Instrlist;$/;"	m	class:Program
Int	include/Type.h	/^		static Type *Int,*Char;$/;"	m	class:Type
Int	lexer/Type.cpp	/^Type* Type::Int = new Type(T_INT , Int_Width , "integer") ;$/;"	m	class:Type	file:
Int_Width	lexer/Type.cpp	2;"	d	file:
LEXER_C	inter/Makefile	/^LEXER_C = Expr.cpp Stmt.cpp $/;"	m
LEXER_C	lexer/Makefile	/^LEXER_C = Lexer.cpp Type.cpp $/;"	m
LEXER_C	parser/Makefile	/^LEXER_C = parsedeclconst.cpp parsedeclpaf.cpp parseexpr.cpp parsestmt.cpp $/;"	m
LEXER_C	symboltable/Makefile	/^LEXER_C = PAF.cpp$/;"	m
LEXER_H	include/Lexer.h	11;"	d
LEXER_H	inter/Makefile	/^LEXER_H = $(HEADER_PATH)\/Lexer.h  $(HEADER_PATH)\/Tag.h $(HEADER_PATH)\/Token.h $(HEADER_PATH)\/Type.h$/;"	m
LEXER_H	lexer/Makefile	/^LEXER_H = $(HEADER_PATH)\/Lexer.h  $(HEADER_PATH)\/Tag.h $(HEADER_PATH)\/Token.h $(HEADER_PATH)\/Type.h$/;"	m
LEXER_H	parser/Makefile	/^LEXER_H = $(HEADER_PATH)\/Lexer.h  $(HEADER_PATH)\/Tag.h $(HEADER_PATH)\/Token.h $(HEADER_PATH)\/Type.h$/;"	m
LEXER_H	symboltable/Makefile	/^LEXER_H = $(HEADER_PATH)\/Lexer.h  $(HEADER_PATH)\/Tag.h $(HEADER_PATH)\/Token.h $(HEADER_PATH)\/Type.h$/;"	m
LEXER_TEST	lexer/Makefile	/^LEXER_TEST = ..\/test\/test_lexer.cpp$/;"	m
LEXER_TEST	parser/Makefile	/^LEXER_TEST = ..\/test\/test_parser.cpp$/;"	m
Lexer	include/Lexer.h	/^class Lexer {$/;"	c
Lexer	lexer/Lexer.cpp	/^Lexer::Lexer(std::string str) {$/;"	f	class:Lexer
MAX_STR_LEN	include/Lexer.h	7;"	d
MAX_WORD_LEN	include/Lexer.h	8;"	d
Minus	include/Token.h	/^		static Word *Minus ; $/;"	m	class:Word
Minus	lexer/Lexer.cpp	/^Word	*Word::Minus = new Word("-",T_MINUS);$/;"	m	class:Word	file:
Mult	include/Token.h	/^		static Word *Mult ; $/;"	m	class:Word
Mult	lexer/Lexer.cpp	/^Word	*Word::Mult = new Word("*",T_MULT);	$/;"	m	class:Word	file:
NODE_H	include/Node.h	9;"	d
Node	include/Node.h	/^	Node () {lexline = Lexer::line;}$/;"	f	class:Node
Node	include/Node.h	/^class Node{$/;"	c
Null	include/PAF.h	/^		static Program* Null;$/;"	m	class:Program
Null	include/Stmt.h	/^		static Stmt* Null;$/;"	m	class:Stmt
Null	inter/Stmt.cpp	/^Stmt* Stmt::Null = new Stmt();         \/\/ null statement generate emptyinstruction$/;"	m	class:Stmt	file:
Null	symboltable/PAF.cpp	/^Program * Program::Null = nullptr;$/;"	m	class:Program	file:
Num	include/Token.h	/^		Num(int v) : Token(T_NUMBER) {value = v;}$/;"	f	class:Num
Num	include/Token.h	/^class Num : public Token{$/;"	c
OBJS	inter/Makefile	/^OBJS = $(patsubst %.cpp,$(BUILDDIR)%.o,$(LEXER_C))$/;"	m
OBJS	lexer/Makefile	/^OBJS = $(patsubst %.cpp,$(BUILDDIR)%.o,$(LEXER_C))$/;"	m
OBJS	parser/Makefile	/^OBJS = $(patsubst %.cpp,$(BUILDDIR)%.o,$(LEXER_C))$/;"	m
OBJS	symboltable/Makefile	/^OBJS = $(patsubst %.cpp,$(BUILDDIR)%.o,$(LEXER_C))$/;"	m
OP	include/OP.h	/^enum OP {$/;"	g
OP_H	include/OP.h	3;"	d
Op	include/Expr.h	/^		Op(Token* tok , Type* t) : Expr(tok , t){}$/;"	f	class:Op
Op	include/Expr.h	/^class Op : public Expr {$/;"	c
OptoString	include/OP.h	/^std::string *OptoString;$/;"	v
OptoString	parser/parsestmt.cpp	/^std::string OptoString[I_MINUS + 1] = {"read","write","if", "iffalse","goto", "param", "callproc", "callfunc", "copy", "copyind","indcopy", "*", "\/", "+", "-"};$/;"	v
Output	include/Stmt.h	/^	Output(Expr *x,STring *string){s = string;e=x;}$/;"	f	class:Output
Output	include/Stmt.h	/^class Output: public Stmt{$/;"	c
PAF_H	include/PAF.h	9;"	d
PARSER_H	include/Parser.h	10;"	d
Parser	include/Parser.h	/^		Parser(Lexer* l) {lex = l; move();}$/;"	f	class:Parser
Parser	include/Parser.h	/^class Parser{$/;"	c
Plus	include/Token.h	/^		static Word *Plus ; $/;"	m	class:Word
Plus	lexer/Lexer.cpp	/^Word	*Word::Plus = new Word("+",T_PLUS);$/;"	m	class:Word	file:
Proc	include/PAF.h	/^class Proc : public Program{$/;"	c
Proc	parser/parsedeclpaf.cpp	/^Proc::Proc(Program  *p,Word *w , int l) { prev = p;name = w;level = l;beginlabel = Parser::getlabel(name);}$/;"	f	class:Proc
Program	include/PAF.h	/^class Program :public Node{$/;"	c
Program	parser/parsedeclpaf.cpp	/^Program::Program(){level = 1;name = new Word("main",T_IDENT);beginlabel = Parser::getlabel(name);}$/;"	f	class:Program
QUADRUPLE_H	include/Quadruple.h	5;"	d
QuadList	include/PAF.h	/^typedef std::vector<Quadruple*> QuadList;$/;"	t
Quadruple	include/Quadruple.h	/^	Quadruple(std::vector<std::string> *l,OP Op, Arg1 * a1, Arg2* a2, Result *r){labellist = new std::vector<std::string>(*l);op = Op;arg1=a1;arg2=a2;result=r;}$/;"	f	class:Quadruple
Quadruple	include/Quadruple.h	/^class Quadruple{$/;"	c
Rel	include/Expr.h	/^class Rel : public Expr {$/;"	c
Rel	inter/Expr.cpp	/^Rel::Rel (Token *t ,Expr *x1 , Expr *x2) : Expr(t,nullptr){$/;"	f	class:Rel
Result	include/Quadruple.h	/^class Result{$/;"	c
Result_label	include/Quadruple.h	/^		Result_label(std::string s){label = s;}$/;"	f	class:Result_label
Result_label	include/Quadruple.h	/^class Result_label : public Result{$/;"	c
STMT_H	include/Stmt.h	7;"	d
STring	include/Token.h	/^		STring(std::string s) : Token(T_STRING){line = s;}$/;"	f	class:STring
STring	include/Token.h	/^class STring : public Token{$/;"	c
Seq	include/Stmt.h	/^	Seq(Stmt *stmt1,Stmt *stmt2){s1 = stmt1; s2 = stmt2;}$/;"	f	class:Seq
Seq	include/Stmt.h	/^class Seq : public Stmt{$/;"	c
Seq_PAF	include/PAF.h	/^	Seq_PAF(Program* p1,Program *p2){paf = p1; pafs = p2;}$/;"	f	class:Seq_PAF
Seq_PAF	include/PAF.h	/^class Seq_PAF : public Program{$/;"	c
Stmt	include/Stmt.h	/^		Stmt(){}$/;"	f	class:Stmt
Stmt	include/Stmt.h	/^class Stmt : public Node{$/;"	c
TEST_O	parser/Makefile	/^TEST_O = ..\/obj\/inter\/Expr.o ..\/obj\/inter\/Stmt.o ..\/obj\/symboltable\/PAF.o ..\/obj\/lexer\/Lexer.o ..\/obj\/lexer\/Type.o$/;"	m
TOKEN_H	include/Token.h	4;"	d
TYPE_H	include/Type.h	3;"	d
Tags_H	include/Tag.h	4;"	d
Temp	include/Expr.h	/^	Temp(Type *t) : Expr(Word::temp , t) {number = ++count;}$/;"	f	class:Temp
Temp	include/Expr.h	/^class Temp : public  Expr {$/;"	c
Token	include/Token.h	/^		Token (Tag i){$/;"	f	class:Token
Token	include/Token.h	/^class Token{$/;"	c
Type	include/Type.h	/^		Type(Tag t , int w, std::string s) : Word(s,t) {width = w;}$/;"	f	class:Type
Type	include/Type.h	/^class Type : public Word{$/;"	c
Unary	include/Expr.h	/^class Unary : public Op { \/\/ its  op will only be minus$/;"	c
Unary	inter/Expr.cpp	/^Unary::Unary(Token *tok, Expr *x) : Op(tok,nullptr) {$/;"	f	class:Unary
Word	include/Token.h	/^		Word(char const *s, Tag tag) : Token(tag) {lexeme = s;}$/;"	f	class:Word
Word	include/Token.h	/^		Word(std::string s, Tag tag) : Token(tag) {lexeme = s;}$/;"	f	class:Word
Word	include/Token.h	/^class Word : public Token{$/;"	c
actuallist	include/Expr.h	/^	std::vector<Expr*> *actuallist;$/;"	m	class:Callfunc
actuallist	include/Stmt.h	/^	std::vector<Expr*> *actuallist;$/;"	m	class:Callproc
addinstr	include/PAF.h	/^		void addinstr(OP op,Arg1* arg1 , Arg2* arg2,Result * result){Instrlist.push_back(new Quadruple(labellist,op,arg1 ,arg2,result)); labellist = nullptr;}$/;"	f	class:Program
addlabel	include/PAF.h	/^		void addlabel(int l ){if(labellist == nullptr) labellist = new std::vector<std::string>(); labellist->push_back("L"+patch::to_string(l));}$/;"	f	class:Program
addlabel	include/PAF.h	/^		void addlabel(std::string s){if(labellist == nullptr) labellist = new std::vector<std::string>(); labellist->push_back(s);}$/;"	f	class:Program
align	include/PAF.h	10;"	d
arg1	include/Quadruple.h	/^	Arg1 * arg1;$/;"	m	class:Quadruple
arg2	include/Quadruple.h	/^	Arg2 * arg2;$/;"	m	class:Quadruple
array	include/Expr.h	/^		Id * array ;$/;"	m	class:Access
array	include/Stmt.h	/^		Id * array;$/;"	m	class:AssignElem
assign	include/Token.h	/^		static Word  *assign;$/;"	m	class:Word
assign	lexer/Lexer.cpp	/^Word *  Word::assign = new Word(":=",T_ASSIGN);$/;"	m	class:Word	file:
assignstatement	parser/parsestmt.cpp	/^Stmt* Parser::assignstatement(){    \/\/ incomplete$/;"	f	class:Parser
beginlabel	include/PAF.h	/^		std::string beginlabel;$/;"	m	class:Program
block	include/PAF.h	/^		Block *block;$/;"	m	class:Program
block	parser/parsestmt.cpp	/^Block* Parser::block(){$/;"	f	class:Parser
c	include/Expr.h	/^		int c ;$/;"	m	class:Constant
callfunc	parser/parseexpr.cpp	/^Callfunc* Parser::callfunc(Func *func){$/;"	f	class:Parser
callprocstatement	parser/parsestmt.cpp	/^Callproc* Parser::callprocstatement(){$/;"	f	class:Parser
character	include/Token.h	/^		char character;$/;"	m	class:Character
check	inter/Expr.cpp	/^bool Rel::check(Type *p1 , Type *p2){$/;"	f	class:Rel
check	inter/Stmt.cpp	/^bool Assign::check(Type *a,Type *b){$/;"	f	class:Assign
check	inter/Stmt.cpp	/^bool AssignElem::check(Type *a ,Type *b){$/;"	f	class:AssignElem
closebracket	include/Token.h	/^		static Word *closebracket ; $/;"	m	class:Word
closebracket	lexer/Lexer.cpp	/^Word	*Word::closebracket = new Word("]",T_CLOSEBRACKET);	$/;"	m	class:Word	file:
closeparenthesis	include/Token.h	/^		static Word *closeparenthesis ; $/;"	m	class:Word
closeparenthesis	lexer/Lexer.cpp	/^Word	*Word::closeparenthesis = new Word(")",T_CLOSEPARENTHESIS);$/;"	m	class:Word	file:
colon	include/Token.h	/^		static Word *colon ; $/;"	m	class:Word
colon	lexer/Lexer.cpp	/^Word	*Word::colon = new Word(":",T_COLON);	$/;"	m	class:Word	file:
column	include/Lexer.h	/^		static int column;$/;"	m	class:Lexer
column	lexer/Lexer.cpp	/^int Lexer::column = 0;$/;"	m	class:Lexer	file:
comma	include/Token.h	/^		static Word *comma ; $/;"	m	class:Word
comma	lexer/Lexer.cpp	/^Word	*Word::comma = new Word(",",T_COMMA);	$/;"	m	class:Word	file:
compoundstmt	parser/parsestmt.cpp	/^Seq* Parser::compoundstmt(){$/;"	f	class:Parser
condition	parser/parseexpr.cpp	/^Rel * Parser::condition(){$/;"	f	class:Parser
constDeclaration	parser/parsedeclconst.cpp	/^void Parser::constDeclaration(){        \/\/  imcomplete due to lack of protaction for const. deal with it$/;"	f	class:Parser
constant	parser/parsedeclconst.cpp	/^Token* Parser::constant(){$/;"	f	class:Parser
constants	parser/parsedeclconst.cpp	/^void Parser::constants(){$/;"	f	class:Parser
count	include/Expr.h	/^	static int count;$/;"	m	class:Temp
count	inter/Expr.cpp	/^int Temp::count = 0;$/;"	m	class:Temp	file:
count	parser/parsestmt.cpp	/^		int count = 1;$/;"	m	class:Parser::labelcounter	file:
decl_constants	parser/parsedeclconst.cpp	/^void Parser::decl_constants(){$/;"	f	class:Parser
decl_variables	parser/parsedeclconst.cpp	/^void Parser::decl_variables(){$/;"	f	class:Parser
dot	include/Token.h	/^		static Word *dot ; $/;"	m	class:Word
dot	lexer/Lexer.cpp	/^Word	*Word::dot = new Word(".",T_DOT);	$/;"	m	class:Word	file:
dowhilestatement	parser/parsestmt.cpp	/^DoWhile* Parser::dowhilestatement(){$/;"	f	class:Parser
e	include/Expr.h	/^		Expr* e;$/;"	m	class:Unary
e	include/Stmt.h	/^		Expr * e;		$/;"	m	class:Assign
e	include/Stmt.h	/^		Expr *e;$/;"	m	class:AssignElem
e	include/Stmt.h	/^		Rel * e;$/;"	m	class:DoWhile
e	include/Stmt.h	/^		Rel * e;$/;"	m	class:IfElse
e	include/Stmt.h	/^		Rel* e;$/;"	m	class:If
e	include/Stmt.h	/^	Expr * e;$/;"	m	class:Output
e1	include/Expr.h	/^		Expr * e1;$/;"	m	class:Arith
e1	include/Expr.h	/^		Expr *e1;$/;"	m	class:Rel
e1	include/Stmt.h	/^		Expr* e1;$/;"	m	class:For
e2	include/Expr.h	/^		Expr * e2;$/;"	m	class:Arith
e2	include/Expr.h	/^		Expr *e2;$/;"	m	class:Rel
e2	include/Stmt.h	/^		Expr* e2;$/;"	m	class:For
emit	include/Node.h	/^	void emit(OP op,Arg1* arg1 , Arg2* arg2,Result * result,Program *p){helper::emit(op,arg1 , arg2, result,p);}$/;"	f	class:Node
emit	inter/Expr.cpp	/^void helper::emit(OP op,Arg1* arg1 , Arg2* arg2,Result * result,Program *p){p->addinstr(op,arg1 , arg2, result);}$/;"	f	class:helper
emitlabel	include/Node.h	/^	void emitlabel(std::string s, Program *p) {helper::emitlabel(s,p);}$/;"	f	class:Node
emitlabel	inter/Expr.cpp	/^void helper::emitlabel(label l,Program *p) {p->addlabel(l);}$/;"	f	class:helper
emitlabel	inter/Expr.cpp	/^void helper::emitlabel(std::string s, Program *p) {p->addlabel(s);}$/;"	f	class:helper
eq	include/Token.h	/^		static Word *eq ; $/;"	m	class:Word
eq	lexer/Lexer.cpp	/^Word	*Word::eq = new Word("=",T_EQ);	$/;"	m	class:Word	file:
error	include/Parser.h	/^		void error(std::string s){;}     \/\/unimplemented$/;"	f	class:Parser
expr	parser/parseexpr.cpp	/^Expr* Parser::expr(){$/;"	f	class:Parser
f	include/Expr.h	/^	Func* f;           \/\/ form para with "var" must correspond to a Id in actual para. should check that$/;"	m	class:Callfunc
factor	parser/parseexpr.cpp	/^Expr* Parser::factor(){$/;"	f	class:Parser
form_para	parser/parsedeclpaf.cpp	/^void Parser::form_para(){$/;"	f	class:Parser
form_para_seg	parser/parsedeclpaf.cpp	/^void Parser::form_para_seg(){$/;"	f	class:Parser
forstatement	parser/parsestmt.cpp	/^For* Parser::forstatement(){        \/\/ incomlete . unchecked identifier information$/;"	f	class:Parser
framesize	include/PAF.h	/^		int framesize;$/;"	m	class:Program
fs	include/Lexer.h	/^		std::fstream *fs;$/;"	m	class:Lexer
func	include/Quadruple.h	/^		Func * func;$/;"	m	class:Arg_func
func_decl	parser/parsedeclpaf.cpp	/^Func* Parser::func_decl(){$/;"	f	class:Parser
ge	include/Token.h	/^		static Word *ge ; $/;"	m	class:Word
ge	lexer/Lexer.cpp	/^Word	*Word::ge = new Word(">=",T_GE);	$/;"	m	class:Word	file:
gen	include/Expr.h	/^		Expr * gen(Program *p) {return new Access(array,type,index->reduce(p));}$/;"	f	class:Access
gen	include/Expr.h	/^		Expr* gen(Program *p){ return new Arith(op, e1->reduce(p) , e2->reduce(p)); }$/;"	f	class:Arith
gen	include/Expr.h	/^		Expr* gen(Program *p){return new Unary(op, e->reduce(p)) ;}$/;"	f	class:Unary
gen	include/Expr.h	/^		virtual Expr* gen(Program *p) {return this;} \/\/genarate a object with its subobject reduced$/;"	f	class:Expr
gen	include/PAF.h	/^		virtual void gen(label begin , label after){};$/;"	f	class:Program
gen	include/Stmt.h	/^		virtual void gen(Program *p){;}$/;"	f	class:Stmt
gen	inter/Expr.cpp	/^Expr* Rel::gen(Program *p){$/;"	f	class:Rel
gen	inter/Stmt.cpp	/^void Assign::gen(Program *p){$/;"	f	class:Assign
gen	inter/Stmt.cpp	/^void AssignElem::gen(Program *p){$/;"	f	class:AssignElem
gen	inter/Stmt.cpp	/^void Callproc::gen(Program *p){$/;"	f	class:Callproc
gen	inter/Stmt.cpp	/^void DoWhile::gen(Program *p)$/;"	f	class:DoWhile
gen	inter/Stmt.cpp	/^void For::gen(Program *p){$/;"	f	class:For
gen	inter/Stmt.cpp	/^void If::gen(Program *p)$/;"	f	class:If
gen	inter/Stmt.cpp	/^void IfElse::gen(Program *p)$/;"	f	class:IfElse
gen	inter/Stmt.cpp	/^void Input::gen(Program *p){$/;"	f	class:Input
gen	inter/Stmt.cpp	/^void Output::gen(Program *p){$/;"	f	class:Output
gen	inter/Stmt.cpp	/^void Seq::gen(Program *p){$/;"	f	class:Seq
get	symboltable/PAF.cpp	/^Node* Program::get(Token *w) {$/;"	f	class:Program
getlabel	parser/parsestmt.cpp	/^std::string Parser::getlabel(Word *w){$/;"	f	class:Parser
gt	include/Token.h	/^		static Word *gt ; $/;"	m	class:Word
gt	lexer/Lexer.cpp	/^Word	*Word::gt = new Word(">",T_GT);	$/;"	m	class:Word	file:
hashtable	include/Lexer.h	/^typedef std::unordered_map<std::string , Word*> hashtable;$/;"	t
helper	include/Node.h	/^namespace helper$/;"	n
id	include/Quadruple.h	/^		Id * id;$/;"	m	class:Arg_id
id	include/Stmt.h	/^		Id * id;$/;"	m	class:For
id	include/Stmt.h	/^		Id* id;$/;"	m	class:Assign
idlist	include/Stmt.h	/^	std::queue<Word*> *idlist;$/;"	m	class:Input
ifstatement	parser/parsestmt.cpp	/^Stmt* Parser::ifstatement(){$/;"	f	class:Parser
index	include/Expr.h	/^		Expr * index ; $/;"	m	class:Access
index	include/Stmt.h	/^		Expr *index;$/;"	m	class:AssignElem
inputstatement	parser/parsestmt.cpp	/^Input* Parser::inputstatement(){$/;"	f	class:Parser
isConst	include/Expr.h	/^		bool isConst;$/;"	m	class:Id
isRef	include/Expr.h	/^		bool isRef = false;$/;"	m	class:Id
is_to	include/Stmt.h	/^		bool is_to;$/;"	m	class:For
label	include/Node.h	/^typedef std::string label;$/;"	t
label	include/Quadruple.h	/^		std::string label;$/;"	m	class:Result_label
labelcounter	parser/parsestmt.cpp	/^		labelcounter(Word* m){x = m;}$/;"	f	class:Parser::labelcounter
labelcounter	parser/parsestmt.cpp	/^class Parser::labelcounter{$/;"	c	class:Parser	file:
labellist	include/PAF.h	/^		std::vector<std::string> *labellist;$/;"	m	class:Program
labellist	include/Quadruple.h	/^	std::vector<std::string> *labellist;$/;"	m	class:Quadruple
labels	include/Node.h	/^	static label labels;$/;"	m	class:Node
labels	inter/Expr.cpp	/^label Node::labels = 0;$/;"	m	class:Node	file:
lcounter	include/Parser.h	/^		static std::unordered_map<Word*,Parser::labelcounter*>  lcounter;$/;"	m	class:Parser
lcounter	parser/parsestmt.cpp	/^std::unordered_map<Word*,Parser::labelcounter*>  Parser::lcounter; $/;"	m	class:Parser	file:
le	include/Token.h	/^		static Word *le ; $/;"	m	class:Word
le	lexer/Lexer.cpp	/^Word	*Word::le = new Word("<=",T_LE);	$/;"	m	class:Word	file:
level	include/Expr.h	/^		int level ;         \/\/don't need level   --no~~~~ we need it$/;"	m	class:Id
level	include/PAF.h	/^		int level;$/;"	m	class:Program
lex	include/Parser.h	/^		Lexer *lex;$/;"	m	class:Parser
lexeme	include/Token.h	/^		std::string lexeme;$/;"	m	class:Word
lexline	include/Node.h	/^	int lexline = 0;$/;"	m	class:Node
line	include/Lexer.h	/^		static int line;         \/\/ not even a declaration!$/;"	m	class:Lexer
line	include/Token.h	/^		std::string line;$/;"	m	class:STring
line	lexer/Lexer.cpp	/^int Lexer::line = 1;$/;"	m	class:Lexer	file:
look	include/Parser.h	/^		Token *look;$/;"	m	class:Parser
lt	include/Token.h	/^		static Word *lt ; $/;"	m	class:Word
lt	lexer/Lexer.cpp	/^Word	*Word::lt = new Word("<",T_LT);	$/;"	m	class:Word	file:
main	test/test_lexer.cpp	/^int main()$/;"	f
main	test/test_parser.cpp	/^int main(){$/;"	f
match	parser/parsestmt.cpp	/^void Parser::match(Tag t){$/;"	f	class:Parser
max	lexer/Type.cpp	/^Type* Type::max(Type *p1, Type *p2)$/;"	f	class:Type
move	include/Parser.h	/^		void move(){look = lex->scan();}$/;"	f	class:Parser
name	include/PAF.h	/^		Word* name;$/;"	m	class:Program
ne	include/Token.h	/^		static Word *ne ; $/;"	m	class:Word
ne	lexer/Lexer.cpp	/^Word	*Word::ne = new Word("<>",T_NE);	$/;"	m	class:Word	file:
newlabel	include/Node.h	/^	label newlabel() {return "L"+patch::to_string(++labels);}$/;"	f	class:Node
number	include/Expr.h	/^	int number = 0;$/;"	m	class:Temp
numeric	lexer/Type.cpp	/^bool Type::numeric(Type *t){$/;"	f	class:Type
of	include/Type.h	/^	Type *of ;$/;"	m	class:Array
offset	include/Expr.h	/^		int offset ;        \/\/ relative address ( of what ?)$/;"	m	class:Id
offset	parser/parseexpr.cpp	/^Access * Parser::offset(Id *id){$/;"	f	class:Parser
op	include/Expr.h	/^		Token *op;$/;"	m	class:Expr
op	include/Quadruple.h	/^	OP	 op;$/;"	m	class:Quadruple
openbracket	include/Token.h	/^		static Word *openbracket ; $/;"	m	class:Word
openbracket	lexer/Lexer.cpp	/^Word	*Word::openbracket = new Word("[",T_OPENBRACKET);	$/;"	m	class:Word	file:
openparenthesis	include/Token.h	/^		static Word *openparenthesis ; $/;"	m	class:Word
openparenthesis	lexer/Lexer.cpp	/^Word	*Word::openparenthesis = new Word("(",T_OPENPARENTHESIS);	$/;"	m	class:Word	file:
optional_para	parser/parsedeclpaf.cpp	/^void Parser::optional_para(){$/;"	f	class:Parser
outputstatement	parser/parsestmt.cpp	/^Output* Parser::outputstatement(){$/;"	f	class:Parser
paf	include/PAF.h	/^	Program* paf;$/;"	m	class:Seq_PAF
pafs	include/PAF.h	/^	Program* pafs;$/;"	m	class:Seq_PAF
para_used	include/PAF.h	/^		int para_used = 0;$/;"	m	class:Func
para_used	include/PAF.h	/^		int para_used = 0;$/;"	m	class:Proc
paralist	include/PAF.h	/^		std::vector<Id*> paralist;$/;"	m	class:Func
paralist	include/PAF.h	/^		std::vector<Id*> paralist;$/;"	m	class:Proc
parentheisfactor	parser/parseexpr.cpp	/^Expr *Parser::parentheisfactor(){$/;"	f	class:Parser
patch	include/Tag.h	/^namespace patch$/;"	n
peek	include/Lexer.h	/^		char peek = ' ';$/;"	m	class:Lexer
prc	include/Stmt.h	/^	Proc* prc;           \/\/ form para with "var" must correspond to a Id in actual para. should check that$/;"	m	class:Callproc
prev	include/PAF.h	/^		Program *prev = nullptr;$/;"	m	class:Program
proc	include/Quadruple.h	/^		Proc * proc;$/;"	m	class:Arg_proc
proc_decl	parser/parsedeclpaf.cpp	/^Proc* Parser::proc_decl(){$/;"	f	class:Parser
program	parser/parsestmt.cpp	/^Program* Parser::program(){$/;"	f	class:Parser
put	include/PAF.h	/^		void put(Token* t , Node* i){symboltable.insert(std::make_pair(t,i));}$/;"	f	class:Program
readch	lexer/Lexer.cpp	/^bool Lexer::readch(char c){$/;"	f	class:Lexer
readch	lexer/Lexer.cpp	/^inline void Lexer::readch(){$/;"	f	class:Lexer
reduce	include/Expr.h	/^		virtual Expr* reduce(Program *p) {return this;} \/\/ resolve to a single address(identifier or constant)$/;"	f	class:Expr
reduce	inter/Expr.cpp	/^Expr* Access::reduce(Program *p){$/;"	f	class:Access
reduce	inter/Expr.cpp	/^Expr* Arith::reduce(Program *p){$/;"	f	class:Arith
reduce	inter/Expr.cpp	/^Expr* Callfunc::reduce(Program *p){$/;"	f	class:Callfunc
reduce	inter/Expr.cpp	/^Expr* Op::reduce(Program*p){$/;"	f	class:Op
reduce	inter/Expr.cpp	/^Expr* Unary::reduce(Program *p){$/;"	f	class:Unary
relation	include/Quadruple.h	/^		Rel * relation;$/;"	m	class:Arg_rel
reserve	include/Lexer.h	/^		void reserve(Word* w) {words.insert(std::make_pair(w->lexeme,w));}$/;"	f	class:Lexer
result	include/Quadruple.h	/^	Result * result;$/;"	m	class:Quadruple
s	include/Stmt.h	/^		Stmt * s;$/;"	m	class:DoWhile
s	include/Stmt.h	/^		Stmt* s;$/;"	m	class:For
s	include/Stmt.h	/^		Stmt* s;$/;"	m	class:If
s	include/Stmt.h	/^	STring * s;$/;"	m	class:Output
s1	include/Stmt.h	/^		Stmt * s1;$/;"	m	class:IfElse
s1	include/Stmt.h	/^	Stmt * s1;$/;"	m	class:Seq
s2	include/Stmt.h	/^		Stmt * s2;$/;"	m	class:IfElse
s2	include/Stmt.h	/^	Stmt * s2;$/;"	m	class:Seq
scan	lexer/Lexer.cpp	/^Token* Lexer::scan(){$/;"	f	class:Lexer
semicolon	include/Token.h	/^		static Word *semicolon ; $/;"	m	class:Word
semicolon	lexer/Lexer.cpp	/^Word	*Word::semicolon = new Word(";",T_SEMICOLON);	$/;"	m	class:Word	file:
seq_constDeclaration	parser/parsedeclconst.cpp	/^void Parser::seq_constDeclaration(){$/;"	f	class:Parser
seq_formpara_seg	parser/parsedeclpaf.cpp	/^void Parser::seq_formpara_seg(){$/;"	f	class:Parser
seq_paf	include/PAF.h	/^	Seq_PAF * seq_paf;$/;"	m	class:Block
seq_paf	parser/parsedeclpaf.cpp	/^Program* Parser::seq_paf(){$/;"	f	class:Parser
seq_statement	parser/parsestmt.cpp	/^Seq* Parser::seq_statement(){$/;"	f	class:Parser
seq_stmt	include/PAF.h	/^	Seq * seq_stmt;$/;"	m	class:Block
seq_variableDeclaration	parser/parsedeclconst.cpp	/^void Parser::seq_variableDeclaration(){$/;"	f	class:Parser
setfsize	include/PAF.h	/^		void setfsize(){framesize = align(used);}        \/\/ align 4$/;"	f	class:Proc
size	include/Type.h	/^	int size = 1;$/;"	m	class:Array
statement	parser/parsestmt.cpp	/^Stmt* Parser::statement(){$/;"	f	class:Parser
str	include/Quadruple.h	/^		std::string str;$/;"	m	class:Arg_string
symboltable	include/PAF.h	/^		Hashtable symboltable;$/;"	m	class:Program
tag	include/Token.h	/^		Tag tag;$/;"	m	class:Token
temp	include/Token.h	/^		static Word *temp;$/;"	m	class:Word
temp	lexer/Lexer.cpp	/^Word    *Word::temp = new Word("temp",T_TEMP);$/;"	m	class:Word	file:
term	parser/parseexpr.cpp	/^Expr* Parser::term(){$/;"	f	class:Parser
toString	include/Token.h	/^		std::string toString() {return patch::to_string(character);}$/;"	f	class:Character
toString	include/Token.h	/^		std::string toString() {return patch::to_string(value);}$/;"	f	class:Num
toString	include/Token.h	/^		std::string toString(){return line;}$/;"	f	class:STring
toString	include/Token.h	/^		string toString() {return lexeme;}$/;"	f	class:Word
toString	include/Token.h	/^		virtual std::string toString(){$/;"	f	class:Token
toString	include/Type.h	/^	std::string toString(){$/;"	f	class:Array
to_string	include/Tag.h	/^    template < typename T > std::string to_string( const T& n )$/;"	f	namespace:patch
top	include/Parser.h	/^		Program * top = nullptr;$/;"	m	class:Parser
type	include/Expr.h	/^		Type *type;$/;"	m	class:Expr
type	include/PAF.h	/^		Type* type;$/;"	m	class:Func
type	parser/parsedeclconst.cpp	/^Type* Parser::type(){$/;"	f	class:Parser
unary	parser/parseexpr.cpp	/^Expr* Parser::unary(){$/;"	f	class:Parser
unsignedexpr	parser/parseexpr.cpp	/^Expr* Parser::unsignedexpr(){$/;"	f	class:Parser
used	include/PAF.h	/^		int used = 0;$/;"	m	class:Program
value	include/Quadruple.h	/^		int value;$/;"	m	class:Arg_int
value	include/Token.h	/^		int value;$/;"	m	class:Character
value	include/Token.h	/^		int value;$/;"	m	class:Num
variableDeclaration	parser/parsedeclconst.cpp	/^void Parser::variableDeclaration(){$/;"	f	class:Parser
variables	parser/parsedeclconst.cpp	/^void Parser::variables(){$/;"	f	class:Parser
width	include/Type.h	/^		int width;$/;"	m	class:Type
words	include/Lexer.h	/^		hashtable words;$/;"	m	class:Lexer
x	parser/parsestmt.cpp	/^		Word* x;$/;"	m	class:Parser::labelcounter	file:
