!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Access	include/Expr.h	/^		Access (Id *id ,Type * t, Expr * e) : Op(new Word("[]" ,T_INDEX),t) {array = id ; index = e }$/;"	f	class:Access
Access	include/Expr.h	/^class Access : public Op{$/;"	c
Arith	include/Expr.h	/^class Arith : public Op {$/;"	c
Arith	inter/Expr.cpp	/^Arith::Arith(Token* tok , Expr *x1 , Expr* x2) : Op(tok, nullptr){$/;"	f	class:Arith
Array	include/Type.h	/^	Array(int sz , Type* t) : Type(T_ARRAY , sz*(t->width), "array")$/;"	f	class:Array
Array	include/Type.h	/^class Array : public Type{$/;"	c
Assign	include/Stmt.h	/^class Assign : public Stmt{$/;"	c
Assign	inter/Stmt.cpp	/^void Assign::Assign(Id *id,Expr *e) {$/;"	f	class:Assign
AssignElem	include/Stmt.h	/^class AssignElem : public Stmt{$/;"	c
AssignElem	inter/Stmt.cpp	/^AssignElem::AssignElem(Access *x , Expr *y){$/;"	f	class:AssignElem
BUILDDIR	lexer/Makefile	/^BUILDDIR = ..\/obj\/lexer\/$/;"	m
Block	include/PAF.h	/^	Block(Program *p){belongto = p;}$/;"	f	class:Block
Block	include/PAF.h	/^class Block {$/;"	c
CC	lexer/Makefile	/^CC = g++$/;"	m
CFLAGS	lexer/Makefile	/^CFLAGS = -Wall -Werror --std=c++11$/;"	m
Callfunc	include/Expr.h	/^class Callfunc : public Expr{$/;"	c
Callproc	include/Stmt.h	/^	Callproc(Proc *proc , std::vector<Expr*> *list){p = proc;list = actuallist;}$/;"	f	class:Callproc
Callproc	include/Stmt.h	/^class Callproc: public stmt{        $/;"	c
Char	include/Type.h	/^		static Type *Int,*Char;$/;"	m	class:Type
Char	lexer/Type.cpp	/^Type* Type::Char = new Type(T_CHAR , Char_Width , "char");  $/;"	m	class:Type	file:
Char_Width	lexer/Type.cpp	3;"	d	file:
Character	include/Token.h	/^		Character(char c) : Token(T_CHARACTER){character = c; value = character;}$/;"	f	class:Character
Character	include/Token.h	/^class Character : public Token{$/;"	c
Compound	include/Stmt.h	/^	Compound(Stmt *stmt1,Stmt *stmt2){s1 = stmt1; s2 = stmt2;}$/;"	f	class:Compound
Compound	include/Stmt.h	/^class Compound : public stmt{$/;"	c
Constant	include/Expr.h	/^		Constant (Character *t): Expr(t , Type::int){c = t->value;}$/;"	f	class:Constant
Constant	include/Expr.h	/^		Constant (Num *t): Expr(t , Type::int){c = t->value;}$/;"	f	class:Constant
Constant	include/Expr.h	/^class Constant : public Expr {$/;"	c
Div	include/Token.h	/^		static Word *Div ; $/;"	m	class:Word
Div	lexer/Lexer.cpp	/^Word	*Word::Div = new Word("\/",T_DIV);	$/;"	m	class:Word	file:
DoWhile	include/Stmt.h	/^		DoWhile(Expr *expr , Stmt *stmt){e = expr;s =stmt;}$/;"	f	class:DoWhile
DoWhile	include/Stmt.h	/^class DoWhile : public Stmt{$/;"	c
ENV_H	include/Env.h	6;"	d
EXPR_H	include/Expr.h	3;"	d
Env	include/Env.h	/^		Env(Env *prev){this.prev = prev;}$/;"	f	class:Env
Env	include/Env.h	/^class Env{$/;"	c
Expr	include/Expr.h	/^		Expr(Token* tok , Type *t) {op = tok ; type = t;}$/;"	f	class:Expr
Expr	include/Expr.h	/^class Expr : public Node{$/;"	c
For	include/Stmt.h	/^		For(Id * i,Expr *x1,bool to,Expr* x2,Stmt* stmt){$/;"	f	class:For
For	include/Stmt.h	/^class For : public Stmt{$/;"	c
Func	include/PAF.h	/^class Func : public Program{$/;"	c
HEADER_PATH	lexer/Makefile	/^HEADER_PATH = ..\/include$/;"	m
Hashtable	include/Env.h	/^typedef std::unordered_map<Token , Node> Hashtable;$/;"	t
Hashtable	include/PAF.h	/^typedef std::unordered_map<Token , Node> Hashtable;$/;"	t
Id	include/Expr.h	/^		Id(Word* w , Type* t , int o , bool b): Expr(w,t) {offset = o; isConst = bool;}$/;"	f	class:Id
Id	include/Expr.h	/^		Id(Word* w , Type* t , int o , bool b1 , bool b2): Expr(w,t) {offset = o; isConst = b1; isRef = b2;}$/;"	f	class:Id
Id	include/Expr.h	/^		Id(Word* w , Type* t , int o): Expr(w,t) {offset = o; isConst = false;}$/;"	f	class:Id
Id	include/Expr.h	/^class Id : public Expr {          \/\/ need add field which specify whether this identifier is const or not$/;"	c
If	include/Stmt.h	/^		If(Expr *expr , Stmt *stmt){e = expr;s =stmt;}$/;"	f	class:If
If	include/Stmt.h	/^		If(Expr *expr , Stmt *stmt1, Stmt *stmt2){e = expr;s1 =stmt1; s2 = stmt2;}$/;"	f	class:IfElse
If	include/Stmt.h	/^class If : public Stmt{$/;"	c
IfElse	include/Stmt.h	/^class IfElse : public Stmt{$/;"	c
Input	include/Stmt.h	/^	Input(std::queue<Word*> *list) {idlist = list;}$/;"	f	class:Input
Input	include/Stmt.h	/^class Input: public stmt{$/;"	c
Int	include/Type.h	/^		static Type *Int,*Char;$/;"	m	class:Type
Int	lexer/Type.cpp	/^Type* Type::Int = new Type(T_INT , Int_Width , "integer") ;$/;"	m	class:Type	file:
Int_Width	lexer/Type.cpp	2;"	d	file:
LEXER_C	lexer/Makefile	/^LEXER_C = Lexer.cpp Type.cpp $/;"	m
LEXER_H	include/Lexer.h	11;"	d
LEXER_H	lexer/Makefile	/^LEXER_H = $(HEADER_PATH)\/Lexer.h  $(HEADER_PATH)\/Tag.h $(HEADER_PATH)\/Token.h $(HEADER_PATH)\/Type.h$/;"	m
LEXER_TEST	lexer/Makefile	/^LEXER_TEST = ..\/test\/test_lexer.cpp$/;"	m
Lexer	include/Lexer.h	/^class Lexer {$/;"	c
Lexer	lexer/Lexer.cpp	/^Lexer::Lexer(std::string str) {$/;"	f	class:Lexer
MAX_STR_LEN	include/Lexer.h	7;"	d
MAX_WORD_LEN	include/Lexer.h	8;"	d
Minus	include/Token.h	/^		static Word *Minus ; $/;"	m	class:Word
Minus	lexer/Lexer.cpp	/^Word	*Word::Minus = new Word("-",T_MINUS);$/;"	m	class:Word	file:
Mult	include/Token.h	/^		static Word *Mult ; $/;"	m	class:Word
Mult	lexer/Lexer.cpp	/^Word	*Word::Mult = new Word("*",T_MULT);	$/;"	m	class:Word	file:
NODE_H	include/Node.h	7;"	d
Node	include/Node.h	/^	Node () {lexline = Lexer::line;}$/;"	f	class:Node
Node	include/Node.h	/^class Node{$/;"	c
Null	include/PAF.h	/^	static Program* Null;$/;"	m	class:Program
Null	include/Stmt.h	/^		static Stmt* Null;$/;"	m	class:Stmt
Null	inter/Stmt.cpp	/^Stmt* Stmt::Null = new Stmt();$/;"	m	class:Stmt	file:
Null	symboltable/PAF.cpp	/^Program * Program::Null = nullptr;$/;"	m	class:Program	file:
Num	include/Token.h	/^		Num(int v) : Token(T_NUMBER) {value = v;}$/;"	f	class:Num
Num	include/Token.h	/^class Num : public Token{$/;"	c
OBJS	lexer/Makefile	/^OBJS = $(patsubst %.cpp,$(BUILDDIR)%.o,$(LEXER_C))$/;"	m
Op	include/Expr.h	/^		Op(Token* tok , Type* t) : Expr(tok , t){}$/;"	f	class:Op
Op	include/Expr.h	/^class Op : public Expr {$/;"	c
Output	include/Stmt.h	/^	Output(Expr *x,STring *string){s = string;e=x;}$/;"	f	class:Output
Output	include/Stmt.h	/^class Output: public stmt{$/;"	c
PAF_H	include/PAF.h	7;"	d
PARSER_H	include/Parser.h	9;"	d
Parser	include/Parser.h	/^		Parser(Lexer* l) {lex = l; move();}$/;"	f	class:Parser
Parser	include/Parser.h	/^class Parser{$/;"	c
Plus	include/Token.h	/^		static Word *Plus ; $/;"	m	class:Word
Plus	lexer/Lexer.cpp	/^Word	*Word::Plus = new Word("+",T_PLUS);$/;"	m	class:Word	file:
Proc	include/PAF.h	/^		Proc(Program  *p,Word *w , int l) { prev = p;name = w;level = l+1;}$/;"	f	class:Proc
Proc	include/PAF.h	/^		Proc(Program *p,Word *w, int l) {prev = p;name = w;level = l+1;}$/;"	f	class:Func
Proc	include/PAF.h	/^class Proc : public Program{$/;"	c
Program	include/PAF.h	/^	Program(){level = 1;}$/;"	f	class:Program
Program	include/PAF.h	/^class Program :public Node{$/;"	c
Rel	include/Expr.h	/^class Rel : public Expr {$/;"	c
Rel	inter/Expr.cpp	/^Rel::Rel (Token *t ,Expr *x1 , Expr *x2) : Expr(t,nullptr){$/;"	f	class:Rel
STMT_H	include/Stmt.h	7;"	d
STring	include/Token.h	/^		STring(std::string s) : Token(T_STRING){line = s;}$/;"	f	class:STring
STring	include/Token.h	/^class STring : public Token{$/;"	c
Seq	include/Stmt.h	/^	Seq(Stmt *stmt1,Stmt *stmt2){s1 = stmt1; s2 = stmt2;}$/;"	f	class:Seq
Seq	include/Stmt.h	/^class Seq : public Stmt{$/;"	c
Seq_PAF	include/PAF.h	/^	Seq_PAF(Program* p1,Program *p2){paf = p1; pafs = p2;}$/;"	f	class:Seq_PAF
Seq_PAF	include/PAF.h	/^class Seq_PAF : public Program{$/;"	c
Stmt	include/Stmt.h	/^		Stmt(){}$/;"	f	class:Stmt
Stmt	include/Stmt.h	/^class Stmt : public Node{$/;"	c
TOKEN_H	include/Token.h	4;"	d
T_ARRAY	include/Tag.h	/^	T_ARRAY , \/\/ array$/;"	e	enum:Tag
T_ASSIGN	include/Tag.h	/^	T_ASSIGN, \/\/ :=$/;"	e	enum:Tag
T_BEGIN	include/Tag.h	/^    T_BEGIN, \/\/ begin$/;"	e	enum:Tag
T_CHAR	include/Tag.h	/^	T_CHAR, \/\/ char$/;"	e	enum:Tag
T_CHARACTER	include/Tag.h	/^	T_CHARACTER, $/;"	e	enum:Tag
T_CLOSEBRACKET	include/Tag.h	/^	T_CLOSEBRACKET, \/\/ ]$/;"	e	enum:Tag
T_CLOSEPARENTHESIS	include/Tag.h	/^	T_CLOSEPARENTHESIS,  \/\/ )$/;"	e	enum:Tag
T_COLON	include/Tag.h	/^	T_COLON, \/\/ :$/;"	e	enum:Tag
T_COMMA	include/Tag.h	/^	T_COMMA, \/\/ ,$/;"	e	enum:Tag
T_CONST	include/Tag.h	/^	T_CONST, \/\/ const$/;"	e	enum:Tag
T_DIV	include/Tag.h	/^	T_DIV, \/\/ \/ $/;"	e	enum:Tag
T_DO	include/Tag.h	/^    T_DO,  \/\/ do$/;"	e	enum:Tag
T_DOT	include/Tag.h	/^	T_DOT, \/\/ .$/;"	e	enum:Tag
T_DOWNTO	include/Tag.h	/^	T_DOWNTO, \/\/ downto$/;"	e	enum:Tag
T_ELSE	include/Tag.h	/^	T_ELSE, \/\/ else$/;"	e	enum:Tag
T_END	include/Tag.h	/^    T_END, \/\/ end$/;"	e	enum:Tag
T_EQ	include/Tag.h	/^	T_EQ, \/\/ =$/;"	e	enum:Tag
T_FOR	include/Tag.h	/^	T_FOR, \/\/ for$/;"	e	enum:Tag
T_FUNCTION	include/Tag.h	/^	T_FUNCTION, \/\/ function$/;"	e	enum:Tag
T_GE	include/Tag.h	/^	T_GE, \/\/ >=$/;"	e	enum:Tag
T_GT	include/Tag.h	/^	T_GT, \/\/ >$/;"	e	enum:Tag
T_IDENT	include/Tag.h	/^	T_IDENT,$/;"	e	enum:Tag
T_IF	include/Tag.h	/^    T_IF, \/\/ if$/;"	e	enum:Tag
T_INDEX	include/Tag.h	/^	T_INDEX , $/;"	e	enum:Tag
T_INT	include/Tag.h	/^	T_INT, \/\/ integer$/;"	e	enum:Tag
T_LE	include/Tag.h	/^	T_LE, \/\/ <=$/;"	e	enum:Tag
T_LT	include/Tag.h	/^	T_LT, \/\/ <$/;"	e	enum:Tag
T_MINUS	include/Tag.h	/^	T_MINUS, \/\/ -$/;"	e	enum:Tag
T_MULT	include/Tag.h	/^	T_MULT, \/\/ *$/;"	e	enum:Tag
T_NE	include/Tag.h	/^	T_NE, \/\/ <>$/;"	e	enum:Tag
T_NULL	include/Tag.h	/^	T_NULL = 256,$/;"	e	enum:Tag
T_NUMBER	include/Tag.h	/^	T_NUMBER,      \/\/unsigned number$/;"	e	enum:Tag
T_OF	include/Tag.h	/^	T_OF, \/\/ of$/;"	e	enum:Tag
T_OPENBRACKET	include/Tag.h	/^	T_OPENBRACKET, \/\/ [$/;"	e	enum:Tag
T_OPENPARENTHESIS	include/Tag.h	/^	T_OPENPARENTHESIS, \/\/ ($/;"	e	enum:Tag
T_PLUS	include/Tag.h	/^	T_PLUS, \/\/ + $/;"	e	enum:Tag
T_PROCEDURE	include/Tag.h	/^    T_PROCEDURE, \/\/ procedure$/;"	e	enum:Tag
T_READ	include/Tag.h	/^	T_READ, \/\/ read$/;"	e	enum:Tag
T_SEMICOLON	include/Tag.h	/^	T_SEMICOLON, \/\/ ;$/;"	e	enum:Tag
T_STRING	include/Tag.h	/^	T_STRING,$/;"	e	enum:Tag
T_TEMP	include/Tag.h	/^	T_TEMP ,$/;"	e	enum:Tag
T_THEN	include/Tag.h	/^    T_THEN, \/\/ then$/;"	e	enum:Tag
T_TO	include/Tag.h	/^	T_TO, \/\/ to$/;"	e	enum:Tag
T_VAR	include/Tag.h	/^	T_VAR, \/\/ var$/;"	e	enum:Tag
T_WHILE	include/Tag.h	/^    T_WHILE, \/\/ while$/;"	e	enum:Tag
T_WRITE	include/Tag.h	/^	T_WRITE, \/\/ write$/;"	e	enum:Tag
Tag	include/Tag.h	/^enum Tag{$/;"	g
Tag_Set	parser/parsedeclconst.cpp	/^typedef std::unordered_set<Tag> Tag_Set;$/;"	t	file:
Tag_Set	parser/parsedeclpaf.cpp	/^typedef std::unordered_set<Tag> Tag_Set;$/;"	t	file:
Tag_Set	parser/parsestmt.cpp	/^typedef std::unordered_set<Tag> Tag_Set;$/;"	t	file:
Tags_H	include/Tag.h	2;"	d
Temp	include/Expr.h	/^	Temp(Type *t) : Expr(Word::temp , t) {number += count;}$/;"	f	class:Temp
Temp	include/Expr.h	/^class Temp : public  Expr {$/;"	c
Token	include/Token.h	/^		Token (Tag i){$/;"	f	class:Token
Token	include/Token.h	/^class Token{$/;"	c
Type	include/Type.h	/^		Type(Tag t , int w, std::string s) : Word(s,t) {width = w;}$/;"	f	class:Type
Type	include/Type.h	/^class Type : public Word{$/;"	c
Unary	include/Expr.h	/^class Unary : public Op {$/;"	c
Unary	inter/Expr.cpp	/^Unary::Unary(Token *tok, Expr *x) : Op(tok,null) {$/;"	f	class:Unary
Word	include/Token.h	/^		Word(char const *s, Tag tag) : Token(tag) {lexeme = s;}$/;"	f	class:Word
Word	include/Token.h	/^		Word(std::string s, Tag tag) : Token(tag) {lexeme = s;}$/;"	f	class:Word
Word	include/Token.h	/^class Word : public Token{$/;"	c
actuallist	include/Stmt.h	/^	std::vector<Expr*> *actuallist;$/;"	m	class:Callproc
array	include/Expr.h	/^		Id * array ;$/;"	m	class:Access
array	include/Stmt.h	/^		Id * array;$/;"	m	class:AssignElem
assign	include/Token.h	/^		static Word  *assign;$/;"	m	class:Word
assign	lexer/Lexer.cpp	/^Word *  Word::assign = new Word(":=",T_ASSIGN);$/;"	m	class:Word	file:
assignstatement	parser/parsestmt.cpp	/^Stmt* Parser::assignstatement(Word* dest){    \/\/ incomplete $/;"	f	class:Parser
belongto	include/PAF.h	/^	Program * belongto;$/;"	m	class:Block
block	include/PAF.h	/^	Block *block;$/;"	m	class:Program
block	parser/parsestmt.cpp	/^Block* Parser::block(){$/;"	f	class:Parser
c	include/Expr.h	/^		int c ;$/;"	m	class:Constant
callprocstatement	parser/parsestmt.cpp	/^Stmt* Parser::callprocstatement(){$/;"	f	class:Parser
character	include/Token.h	/^		char character;$/;"	m	class:Character
check	inter/Expr.cpp	/^bool Rel::check(Type *p1 , Type *p2){$/;"	f	class:Rel
check	inter/Stmt.cpp	/^bool Assign::check(Type *a,Type *b){$/;"	f	class:Assign
check	inter/Stmt.cpp	/^bool AssignElem::check(Type *a ,Type *b){$/;"	f	class:AssignElem
closebracket	include/Token.h	/^		static Word *closebracket ; $/;"	m	class:Word
closebracket	lexer/Lexer.cpp	/^Word	*Word::closebracket = new Word("]",T_CLOSEBRACKET);	$/;"	m	class:Word	file:
closeparenthesis	include/Token.h	/^		static Word *closeparenthesis ; $/;"	m	class:Word
closeparenthesis	lexer/Lexer.cpp	/^Word	*Word::closeparenthesis = new Word(")",T_CLOSEPARENTHESIS);$/;"	m	class:Word	file:
colon	include/Token.h	/^		static Word *colon ; $/;"	m	class:Word
colon	lexer/Lexer.cpp	/^Word	*Word::colon = new Word(":",T_COLON);	$/;"	m	class:Word	file:
column	include/Lexer.h	/^		static int column;$/;"	m	class:Lexer
column	lexer/Lexer.cpp	/^int Lexer::column = 0;$/;"	m	class:Lexer	file:
comma	include/Token.h	/^		static Word *comma ; $/;"	m	class:Word
comma	lexer/Lexer.cpp	/^Word	*Word::comma = new Word(",",T_COMMA);	$/;"	m	class:Word	file:
compoundstmt	parser/parsestmt.cpp	/^Stmt* Parser::compoundstmt(){$/;"	f	class:Parser
condition	parser/parseexpr.cpp	/^Rel * Parser::condition(){$/;"	f	class:Parser
constDeclaration	parser/parsedeclconst.cpp	/^void Parser::constDeclaration(){        \/\/  imcomplete due to lack of protaction for const. deal with it$/;"	f	class:Parser
constant	parser/parsedeclconst.cpp	/^Token* Parser::constant(){$/;"	f	class:Parser
constants	parser/parsedeclconst.cpp	/^void Parser::constants(){$/;"	f	class:Parser
count	include/Expr.h	/^	static int count;$/;"	m	class:Temp
decl_constants	parser/parsedeclconst.cpp	/^void Parser::decl_constants(){$/;"	f	class:Parser
decl_variables	parser/parsedeclconst.cpp	/^void Parser::decl_variables(){$/;"	f	class:Parser
dot	include/Token.h	/^		static Word *dot ; $/;"	m	class:Word
dot	lexer/Lexer.cpp	/^Word	*Word::dot = new Word(".",T_DOT);	$/;"	m	class:Word	file:
dowhilestatement	parser/parsestmt.cpp	/^Stmt* Parser::dowhilestatement(){$/;"	f	class:Parser
e	include/Expr.h	/^		Expr* e;$/;"	m	class:Unary
e	include/Stmt.h	/^		Expr * e;		$/;"	m	class:Assign
e	include/Stmt.h	/^		Expr * e;$/;"	m	class:DoWhile
e	include/Stmt.h	/^		Expr * e;$/;"	m	class:IfElse
e	include/Stmt.h	/^		Expr *e;$/;"	m	class:AssignElem
e	include/Stmt.h	/^		Expr* e;$/;"	m	class:If
e	include/Stmt.h	/^	Expr * e;$/;"	m	class:Output
e1	include/Expr.h	/^		Expr * e1;$/;"	m	class:Arith
e1	include/Expr.h	/^		Expr *e1;$/;"	m	class:Rel
e1	include/Stmt.h	/^		Expr* e1;$/;"	m	class:For
e2	include/Expr.h	/^		Expr * e2;$/;"	m	class:Arith
e2	include/Expr.h	/^		Expr *e2;$/;"	m	class:Rel
e2	include/Stmt.h	/^		Expr* e2;$/;"	m	class:For
emit	include/Node.h	/^	void emit(std::string s) {std::cout <<"\\t"<< s << endl;}$/;"	f	class:Node
emitjumps	inter/Expr.cpp	/^virtual void Expr::emitjumps(std::string test , label iftrue , label iffalse){$/;"	f	class:Expr
emitlabel	include/Node.h	/^	void emitlabel(label l) {std::cout << "L" + i + ":";}$/;"	f	class:Node
eq	include/Token.h	/^		static Word *eq ; $/;"	m	class:Word
eq	lexer/Lexer.cpp	/^Word	*Word::eq = new Word("=",T_EQ);	$/;"	m	class:Word	file:
error	include/Parser.h	/^		void error(std::string s){;}     \/\/unimplemented$/;"	f	class:Parser
expr	parser/parseexpr.cpp	/^Expr* Parser::expr(){$/;"	f	class:Parser
expr	parser/parseexpr.cpp	/^Expr* expr(){$/;"	f
factor	parser/parseexpr.cpp	/^Expr* Parser::factor(){$/;"	f	class:Parser
form_para	parser/parsedeclpaf.cpp	/^void Parser::form_para(){$/;"	f	class:Parser
form_para_seg	parser/parsedeclpaf.cpp	/^void Parser::form_para_seg(){$/;"	f	class:Parser
forstatement	parser/parsestmt.cpp	/^Stmt* Parser::forstatement(){        \/\/ incomlete . unchecked identifier information$/;"	f	class:Parser
fs	include/Lexer.h	/^		std::fstream *fs;$/;"	m	class:Lexer
func_decl	parser/parsedeclpaf.cpp	/^Func* Parser::func_decl(){$/;"	f	class:Parser
ge	include/Token.h	/^		static Word *ge ; $/;"	m	class:Word
ge	lexer/Lexer.cpp	/^Word	*Word::ge = new Word(">=",T_GE);	$/;"	m	class:Word	file:
gen	include/Expr.h	/^		Arith(Token* tok , Expr *x1 , Expr* x2); Expr* gen(){ return new Arith(op, e1.reduce() , e2.reduce()); }$/;"	f	class:Arith
gen	include/Expr.h	/^		Expr * gen() {return new Access*(id,t,e->reduce());}$/;"	f	class:Access
gen	include/Expr.h	/^		Expr* gen(){return new Unary(Op, e.reduce()) ;}$/;"	f	class:Unary
gen	include/Expr.h	/^		virtual Expr* gen() {return this;}$/;"	f	class:Expr
gen	include/PAF.h	/^	virtual gen(label begin , label after){};$/;"	f	class:Program
gen	include/Stmt.h	/^		virtual gen(label begin , label after){}$/;"	f	class:Stmt
gen	include/Stmt.h	/^		void gen(label begin , label after){emit(id->toString()+" = "+e->gen()->toString());}$/;"	f	class:Assign
gen	inter/Stmt.cpp	/^void AssignElem::gen(label begin,label after){$/;"	f	class:AssignElem
gen	inter/Stmt.cpp	/^void DoWhile::gen(label before, label after)$/;"	f	class:DoWhile
gen	inter/Stmt.cpp	/^void If::gen(label before, label after)$/;"	f	class:If
gen	inter/Stmt.cpp	/^void IfElse::gen(label before, label after)$/;"	f	class:IfElse
gen	inter/Stmt.cpp	/^void Seq::gen(label begin , label after){$/;"	f	class:Seq
get	symboltable/PAF.cpp	/^Id* Program::get(Token *w) {$/;"	f	class:Program
gt	include/Token.h	/^		static Word *gt ; $/;"	m	class:Word
gt	lexer/Lexer.cpp	/^Word	*Word::gt = new Word(">",T_GT);	$/;"	m	class:Word	file:
hashtable	include/Lexer.h	/^typedef std::unordered_map<std::string , Word*> hashtable;$/;"	t
id	include/Stmt.h	/^		Id * id;$/;"	m	class:For
id	include/Stmt.h	/^		Id* id;$/;"	m	class:Assign
idlist	include/Stmt.h	/^	std::queue<Word*> *idlist;$/;"	m	class:Input
ifstatement	parser/parsestmt.cpp	/^Stmt* Parser::ifstatement(){$/;"	f	class:Parser
index	include/Expr.h	/^		Expr * index ; $/;"	m	class:Access
index	include/Stmt.h	/^		Expr *index;$/;"	m	class:AssignElem
inputstatement	parser/parsestmt.cpp	/^Stmt* Parser::inputstatement(){$/;"	f	class:Parser
isConst	include/Expr.h	/^		bool isConst;$/;"	m	class:Id
isRef	include/Expr.h	/^		bool isRef = false;$/;"	m	class:Id
is_to	include/Stmt.h	/^		bool is_to;$/;"	m	class:For
jumping	include/Expr.h	/^		void jumping(label iftrue, label iffalse) {emitjumps(reduce()->toString(),t,f);}$/;"	f	class:Access
jumping	inter/Expr.cpp	/^virtual void Expr::jumping(label iftrue , label iffalse){$/;"	f	class:Expr
l	include/PAF.h	/^		label l;                     \/\/ L label:$/;"	m	class:Func
l	include/PAF.h	/^		label l;$/;"	m	class:Proc
label	include/Node.h	/^typedef int label;$/;"	t
labels	include/Node.h	/^	static label labels;$/;"	m	class:Node
labels	inter/Expr.cpp	/^label Node::labels = 0;$/;"	m	class:Node	file:
le	include/Token.h	/^		static Word *le ; $/;"	m	class:Word
le	lexer/Lexer.cpp	/^Word	*Word::le = new Word("<=",T_LE);	$/;"	m	class:Word	file:
level	include/Expr.h	/^		int level ;$/;"	m	class:Id
level	include/PAF.h	/^	int level;$/;"	m	class:Program
lex	include/Parser.h	/^		Lexer *lex;$/;"	m	class:Parser
lexeme	include/Token.h	/^		std::string lexeme;$/;"	m	class:Word
lexline	include/Node.h	/^	int lexline = 0;$/;"	m	class:Node
line	include/Lexer.h	/^		static int line;         \/\/ not even a declaration!$/;"	m	class:Lexer
line	include/Token.h	/^		std::string line;$/;"	m	class:STring
line	lexer/Lexer.cpp	/^int Lexer::line = 1;$/;"	m	class:Lexer	file:
look	include/Parser.h	/^		Token *look;$/;"	m	class:Parser
lt	include/Token.h	/^		static Word *lt ; $/;"	m	class:Word
lt	lexer/Lexer.cpp	/^Word	*Word::lt = new Word("<",T_LT);	$/;"	m	class:Word	file:
main	test/test_lexer.cpp	/^int main()$/;"	f
match	parser/parsestmt.cpp	/^void Parser::match(Tag t){$/;"	f	class:Parser
max	lexer/Type.cpp	/^Type* Type::max(Type *p1, Type *p2)$/;"	f	class:Type
move	include/Parser.h	/^		void move(){look = lex->scan();}$/;"	f	class:Parser
name	include/PAF.h	/^		Word* name; $/;"	m	class:Func
name	include/PAF.h	/^		Word* name; $/;"	m	class:Proc
ne	include/Token.h	/^		static Word *ne ; $/;"	m	class:Word
ne	lexer/Lexer.cpp	/^Word	*Word::ne = new Word("<>",T_NE);	$/;"	m	class:Word	file:
newlabel	include/Node.h	/^	label newlabel() {return ++labels;}$/;"	f	class:Node
number	include/Expr.h	/^	int number = 0;$/;"	m	class:Temp
numeric	lexer/Type.cpp	/^Type* Type::numeric(Type *t){$/;"	f	class:Type
of	include/Type.h	/^	Type *of ;$/;"	m	class:Array
offset	include/Expr.h	/^		int offset ;        \/\/ relative address ( of what ?)$/;"	m	class:Id
op	include/Expr.h	/^		Token *op;$/;"	m	class:Expr
openbracket	include/Token.h	/^		static Word *openbracket ; $/;"	m	class:Word
openbracket	lexer/Lexer.cpp	/^Word	*Word::openbracket = new Word("[",T_OPENBRACKET);	$/;"	m	class:Word	file:
openparenthesis	include/Token.h	/^		static Word *openparenthesis ; $/;"	m	class:Word
openparenthesis	lexer/Lexer.cpp	/^Word	*Word::openparenthesis = new Word("(",T_OPENPARENTHESIS);	$/;"	m	class:Word	file:
optional_para	parser/parsedeclpaf.cpp	/^void Parser::optional_para(){$/;"	f	class:Parser
outputstatement	parser/parsestmt.cpp	/^Stmt* Parser::outputstatement(){$/;"	f	class:Parser
p	include/Stmt.h	/^	Proc* p;           \/\/ form para with "var" must correspond to a Id in actual para. should check that$/;"	m	class:Callproc
paf	include/PAF.h	/^	Program* paf;$/;"	m	class:Seq_PAF
pafs	include/PAF.h	/^	Program* pafs;$/;"	m	class:Seq_PAF
paralist	include/PAF.h	/^		std::vector<Id*> paralist;$/;"	m	class:Func
paralist	include/PAF.h	/^		std::vector<Id*> paralist;$/;"	m	class:Proc
parentheisfactor	parser/parseexpr.cpp	/^Expr *Parser::parentheisfactor(){$/;"	f	class:Parser
peek	include/Lexer.h	/^		char peek = ' ';$/;"	m	class:Lexer
prev	include/Env.h	/^		Env *prev;$/;"	m	class:Env
prev	include/PAF.h	/^		Program *prev;$/;"	m	class:Func
prev	include/PAF.h	/^		Program *prev;$/;"	m	class:Proc
proc_decl	parser/parsedeclpaf.cpp	/^Proc* Parser::proc_decl(){$/;"	f	class:Parser
program	parser/parsestmt.cpp	/^Program* Parser::program(){$/;"	f	class:Parser
put	include/Env.h	/^		void put(Token* t , Node* i){table.insert(std::make_pair(t,i))}$/;"	f	class:Env
put	include/PAF.h	/^	void put(Token* t , Node* i){table.insert(std::make_pair(t,i))}$/;"	f	class:Program
readch	lexer/Lexer.cpp	/^bool Lexer::readch(char c){$/;"	f	class:Lexer
readch	lexer/Lexer.cpp	/^inline void Lexer::readch(){$/;"	f	class:Lexer
reduce	inter/Expr.cpp	/^Expr* Op::reduce(){$/;"	f	class:Op
reserve	include/Lexer.h	/^		void reserve(Word* w) {words.insert(std::make_pair(w->lexeme,w));}$/;"	f	class:Lexer
s	include/Stmt.h	/^		Stmt * s;$/;"	m	class:DoWhile
s	include/Stmt.h	/^		Stmt* s;$/;"	m	class:For
s	include/Stmt.h	/^		Stmt* s;$/;"	m	class:If
s	include/Stmt.h	/^	STring * s;$/;"	m	class:Output
s1	include/Stmt.h	/^		Stmt * s1;$/;"	m	class:IfElse
s1	include/Stmt.h	/^	Stmt * s1;$/;"	m	class:Compound
s1	include/Stmt.h	/^	Stmt * s1;$/;"	m	class:Seq
s2	include/Stmt.h	/^		Stmt * s2;$/;"	m	class:IfElse
s2	include/Stmt.h	/^	Stmt * s2;$/;"	m	class:Compound
s2	include/Stmt.h	/^	Stmt * s2;$/;"	m	class:Seq
scan	lexer/Lexer.cpp	/^Token* Lexer::scan(){$/;"	f	class:Lexer
semicolon	include/Token.h	/^		static Word *semicolon ; $/;"	m	class:Word
semicolon	lexer/Lexer.cpp	/^Word	*Word::semicolon = new Word(";",T_SEMICOLON);	$/;"	m	class:Word	file:
seq_constDeclaration	parser/parsedeclconst.cpp	/^void Parser::seq_constDeclaration(){$/;"	f	class:Parser
seq_paf	include/PAF.h	/^	Seq_PAF * seq_paf;$/;"	m	class:Block
seq_paf	parser/parsedeclpaf.cpp	/^Program* Parser::seq_paf(Program *p){$/;"	f	class:Parser
seq_stmt	include/PAF.h	/^	Seq * seq_stmt;$/;"	m	class:Block
seq_variableDeclaration	parser/parsedeclconst.cpp	/^void Parser::seq_variableDeclaration(){$/;"	f	class:Parser
size	include/Type.h	/^	int size = 1;$/;"	m	class:Array
statement	parser/parsestmt.cpp	/^Stmt* Parser::statement(){$/;"	f	class:Parser
symboltable	include/PAF.h	/^	Hashtable symboltable;$/;"	m	class:Program
table	include/Env.h	/^		Hashtable table;$/;"	m	class:Env
tag	include/Token.h	/^		Tag tag;$/;"	m	class:Token
temp	include/Token.h	/^		static Word *temp;$/;"	m	class:Word
temp	lexer/Lexer.cpp	/^Word    *Word::temp = new Word("temp",T_TEMP);$/;"	m	class:Word	file:
term	parser/parseexpr.cpp	/^Expr* Parser::term(){$/;"	f	class:Parser
toString	include/Expr.h	/^		std::string  toString(){return op.toString() + " " + expr.toString();}$/;"	f	class:Unary
toString	include/Expr.h	/^		std::string toString() {return e1.toString() + " " + op.toString + " " + e2.toString();}$/;"	f	class:Arith
toString	include/Expr.h	/^		std::string toString(){return array->toString()+"[" + index.toString + "]";}$/;"	f	class:Access
toString	include/Expr.h	/^		virtual std::string toString(){return op.toString();}$/;"	f	class:Expr
toString	include/Expr.h	/^	std::string toString(){return "t"+number;}$/;"	f	class:Temp
toString	include/Token.h	/^		std::string toString() {return std::to_string(character);}$/;"	f	class:Character
toString	include/Token.h	/^		std::string toString() {return std::to_string(value);}$/;"	f	class:Num
toString	include/Token.h	/^		std::string toString(){return line;}$/;"	f	class:STring
toString	include/Token.h	/^		string toString() {return lexeme;}$/;"	f	class:Word
toString	include/Token.h	/^		virtual std::string toString(){$/;"	f	class:Token
toString	include/Type.h	/^	std::string toString(){$/;"	f	class:Array
top	include/Parser.h	/^		Program * top = nullptr;$/;"	m	class:Parser
type	include/Expr.h	/^		Type *type;$/;"	m	class:Expr
type	include/PAF.h	/^		Type* type;$/;"	m	class:Func
type	parser/parsedeclconst.cpp	/^Type* Parser::type(){$/;"	f	class:Parser
unary	parser/parseexpr.cpp	/^Expr* Parser::unary(){$/;"	f	class:Parser
unsignedexpr	parser/parseexpr.cpp	/^Expr* Parser::unsignedexpr(){$/;"	f	class:Parser
used	include/PAF.h	/^	int used = 0;$/;"	m	class:Program
value	include/Token.h	/^		int value;$/;"	m	class:Character
value	include/Token.h	/^		int value;$/;"	m	class:Num
variableDeclaration	parser/parsedeclconst.cpp	/^void Parser::variableDeclaration(){$/;"	f	class:Parser
variables	parser/parsedeclconst.cpp	/^void Parser::variables(){$/;"	f	class:Parser
width	include/Type.h	/^		int width;$/;"	m	class:Type
words	include/Lexer.h	/^		hashtable words;$/;"	m	class:Lexer
